
{-

N.B.

This version is WORKING.

Implementation: full intended implementation.
Program state is a Model' instead of a Model which
gives O(1) "has this (sub)model changed".
View functions are imbued with a disposable cache
which holds their value since the last view.
Together, we cache.

-}

{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE RecursiveDo #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE LambdaCase #-}

-- suggested for unsafePerformIO
{-# OPTIONS_GHC -fno-cse -fno-full-laziness #-}

module Main where

import Control.Monad (when)
import System.IO.Unsafe (unsafePerformIO)
import Data.Functor ((<&>))
import Data.Functor.Identity (Identity(..))
import Data.Function (on, (&))
import Data.Maybe (isJust, fromJust)
import qualified Data.Map as Map
import Data.Map (Map)
import Data.IORef (IORef, newIORef, writeIORef, readIORef, modifyIORef)

import Miso hiding (on)
import Miso.String

import Debug.Trace

data Expr = Literal Float | Operation Expr Op Expr deriving (Show, Ord, Eq)
data Op = Add | Sub | Mul | Div deriving (Show, Ord, Eq)

eval :: Expr -> Float
eval (Literal x) = x
eval (Operation lhs op rhs) = (eval lhs) `fun` (eval rhs)
  where fun = case op of
          Add -> (+)
          Sub -> (-)
          Mul -> (*)
          Div -> (/)

data Expr'
  = Literal' Float Changedness
  | Operation' Expr' Op' Expr' Changedness
  deriving (Show, Ord, Eq)

data Op'
  = Add' Changedness
  | Sub' Changedness
  | Mul' Changedness
  | Div' Changedness
  deriving (Show, Ord, Eq)

data Changedness = Changed | Unchanged
  deriving (Show, Ord, Eq)

class Nabla nabla where
  changedness :: nabla -> Changedness
  same :: nabla -> nabla  -- recursively let changedness = Unchanged

class Nabla nabla => NablaFor base nabla where
  base :: nabla -> base

wasChanged :: Nabla nabla => nabla -> Bool
wasChanged = changedness <&> (== Changed)

wasn'tChanged :: Nabla nabla => nabla -> Bool
wasn'tChanged = not . wasChanged

instance Nabla Expr' where
  changedness (Literal' _ c) = c
  changedness (Operation' _ _ _ c) = c

  same (Literal' x _) = Literal' x Unchanged
  same (Operation' lhs' op' rhs' _) = Operation' (same lhs') (same op') (same rhs') Unchanged

instance NablaFor Expr Expr' where
  base (Literal' x _) = Literal x
  base (Operation' lhs' op' rhs' _) = Operation (base lhs') (base op') (base rhs')

instance Nabla Op' where
  changedness (Add' c) = c
  changedness (Sub' c) = c
  changedness (Mul' c) = c
  changedness (Div' c) = c

  same (Add' _) = Add' Unchanged
  same (Sub' _) = Sub' Unchanged
  same (Mul' _) = Mul' Unchanged
  same (Div' _) = Div' Unchanged

instance NablaFor Op Op' where
  base (Add' _) = Add
  base (Sub' _) = Sub
  base (Mul' _) = Mul
  base (Div' _) = Div

main :: IO ()
main = startApp App
  { initialAction = id
  , model = initialModel
  , update = \step model -> return (traceShowId $ step model)
  , view = viewFunc
  , events = defaultEvents
  , subs = []
  , mountPoint = Nothing
  , logLevel = Off
  }
  where
    initialModel = Literal' 0 Changed

    {-# NOINLINE viewFunc #-} -- suggested 'cuz unsafePerformIO
    viewFunc model = (unsafePerformIO $ ffRun viewTop model) id

type Step a = a -> a
type Nestle here there = Step here -> Step there
type Html model = View (Step model)
type Component there here = Nestle here there -> Html there

data (-%>) p r = Fruitfly
  { ffRun :: p -> IO r
  , ffShift :: IO ()
  }

nablafly :: forall base nabla r. (NablaFor base nabla, Ord base, Show nabla) => (nabla -> IO r) -> IO (nabla -%> r)
nablafly func = do
  putCacheRef :: IORef (Map base r) <- newIORef Map.empty
  getCacheRef :: IORef (Map base r) <- newIORef Map.empty

  return $ Fruitfly
    { ffRun = \param -> do
        trace "ok" $ return ()
        result <-
          if wasn'tChanged param
          then readIORef getCacheRef <&> confidentLookup (base param)
               & trace "cache: USED"
          else func param
        modifyIORef putCacheRef (Map.insert (base param) result)
        --modifyIORef getCacheRef (Map.insert (base param) result) -- TODO: remove
        return result

    , ffShift = do  -- TODO: use this lol
        writeIORef getCacheRef =<< readIORef putCacheRef
        writeIORef putCacheRef Map.empty
    }

  where
    -- Map lookup assuming existence of an associated value
    confidentLookup :: Ord k => k -> Map k v -> v
    confidentLookup key map
      | Map.size map == 1 = Map.elems map !! 0
      | otherwise = fromJust $ Map.lookup key map

idfly :: (a -> IO b) -> (a -%> b)
idfly f = Fruitfly { ffRun = f, ffShift = return () }

{-# NOINLINE viewTop #-} -- suggested 'cuz unsafePerformIO
viewTop :: Expr' -%> Component there Expr'
viewTop = unsafePerformIO $ mdo

  viewExpr' :: Expr' -%> Component there Expr'
    <- (nablafly @Expr $ \expr' -> case expr' of

          literal'@(Literal' x _) -> return $ \nestle ->
            span_ [ class_ "number" ]
              [ input_ [ type_ "number"
                       , value_ (toMisoString . show $ (round x :: Int))
                       , onChange (\str -> nestle $ \_model -> Literal' (read $ fromMisoString str) Changed)
                       ]
              , text " "
              , button_ [ onClick (nestle $ \model -> Operation' model (Add' Changed) model Changed) ] [] -- TODO: repositioning
              ]

          operation'@(Operation' lhs' op' rhs' _) -> mdo
              lhsComponent <- ffRun viewExpr' lhs'
              opComponent  <- ffRun viewOp'   op'
              rhsComponent <- ffRun viewExpr' rhs'
              return $ \nestle -> let
                lhsHtml  = lhsComponent $ \step -> nestle $ \(Operation' l o r _) -> Operation' (step l) (same o) (same r) Changed
                opHtml   = opComponent  $ \step -> nestle $ \(Operation' l o r _) -> Operation' (same l) (step o) (same r) Changed
                rhsHtml  = rhsComponent $ \step -> nestle $ \(Operation' l o r _) -> Operation' (same l) (same o) (step r) Changed
                -- ^ TODO: for next version, switch from 'same' to using paths (perhaps) which wouldnt need 'same'
                in span_ [ class_ "parens" ] [ lhsHtml, text " ", opHtml, text " ", rhsHtml ]
        )

  viewOp' :: Op' -%> Component there Op'
    <- (nablafly @Op $ \op' -> return $ \nestle ->
          select_
            [ onChange (\str -> nestle $ \_model -> unstringify str) ]
            ([Add, Sub, Mul, Div] <&> \op ->
              option_ [ selected_ (op == base op')
                      , value_ (stringify op)
                      ]
                      [ text . stringify $ op ])
        )

  let stringify = (\case
        Add -> toMisoString ("+" :: String)
        Sub -> toMisoString ("-" :: String)
        Mul -> toMisoString ("×" :: String)
        Div -> toMisoString ("÷" :: String))

  let unstringify = (\s ->
        case fromMisoString s :: String of
          "+" -> Add' Changed
          "-" -> Sub' Changed
          "×" -> Mul' Changed
          "÷" -> Div' Changed)

  viewTop_impl :: Expr' -%> Component there Expr'
    <- (nablafly @Expr $ \expr' -> do
          exprComponent <- ffRun viewExpr' expr'
          return $ \nestle ->
            div_ []
              [ link_ [ rel_ "stylesheet", href_ "../../../main.css" ]
              , exprComponent nestle
              , text " = "
              , text . toMisoString . show $ eval (base expr')
              ]
        )

  let viewTop_wrapped = idfly $ \expr' -> do
        result <- ffRun viewTop_impl expr'
        ffShift viewExpr'
        ffShift viewOp'
        ffShift viewTop_impl
        return result

  return viewTop_wrapped
